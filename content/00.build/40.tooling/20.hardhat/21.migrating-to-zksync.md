---
title: Migrating deploy scripts to the ZKsync
description: Learn how to migrate an existing Hardhat project deploy scripts to ZKsync Era.
---

## Project setup

The `@matterlabs/hardhat-zksync` includes all the necessary tools to compile, test, and deploy contracts on ZKsync.

1. Install the `@matterlabs/hardhat-zksync` plugin with:

::code-group

```bash [npm]
npm i -D @matterlabs/hardhat-zksync
```

```bash [yarn]
yarn add -D @matterlabs/hardhat-zksync
```

```bash [pnpm]
pnpm i -D @matterlabs/hardhat-zksync
```

```bash [bun]
bun add @matterlabs/hardhat-zksync
```

::

1. Add the preferred ZKsync networks to the `hardhat.config.ts` file:

```js
networks: {
    zkSyncSepoliaTestnet: {
      url: "https://sepolia.era.zksync.dev",
      ethNetwork: "sepolia",
      zksync: true,
      verifyURL: "https://explorer.sepolia.era.zksync.dev/contract_verification",
    },
    zkSyncMainnet: {
      url: "https://mainnet.era.zksync.io",
      ethNetwork: "mainnet",
      zksync: true,
      verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
    },
    dockerizedNode: {
      url: "http://localhost:3050",
      ethNetwork: "http://localhost:8545",
      zksync: true,
    },
    inMemoryNode: {
      url: "http://127.0.0.1:8011",
      ethNetwork: "localhost", // in-memory node doesn't support eth node; removing this line will cause an error
      zksync: true,
    },
    // Other networks

}
```

::callout{icon="i-heroicons-light-bulb"}
You can also add the `zksync:true` flag to the hardhat network.
::

## Compilation

ZKsync Era (as well as other chains built with ZK Stack) is operated by the EraVM,
which executes a specific bytecode that differs from the EVM.
This bytecode is generated by the `zksolc` (for Solidity contracts)
and `zkvyper` (for Vyper contracts) compilers.

To compile your contracts with these compilers, follow these steps:

1. Make sure that the `@matterlabs/hardhat-zksync` plugin is installed
and imported in the `hardhat.config.ts` file, and that the ZKsync networks are included in the network list.

2. Run the compilation task targeting one of the ZKsync networks:

```bash
npx hardhat compile --network zkSyncSepoliaTestnet
```

1. The following output indicates the contracts are being compiled with the `zksolc` compiler:

```bash
Compiling contracts for ZKsync Era with zksolc v1.5.1 and zkvm-solc v0.8.17-1.0.1
Compiling 42 Solidity files
```

1. The compiler generates the `artifacts-zk` and `cache-zk` folders containing the smart contract correspondent artifacts.

### Compiler settings

You can modify different compiler settings in the `zksolc` or `zkvyper` property inside the `hardhat.config.ts` file.

- Check the [available `zksolc` settings here](/build/tooling/hardhat/hardhat-zksync-solc#configuration).
- Check the [available `zkvyper` settings here](/build/tooling/hardhat/hardhat-zksync-vyper#configuration).

### Non-inline Libraries

Deploying non-inline libraries on ZKsync differs from Ethereum. If your project contains non-inline libraries, the compilation command will fail.

Now deployment script can be executed and for selected network it will deploy all missing libraries and continue with deployment scripts.

::code-group

```typescript [hardhat-ethers]
const firstLibrary = await hre.ethers.deployContract("LibraryA");
await firstLibrary.waitForDeployment();
const firstLibraryAddress = await firstLibrary.getAddress()

const secondLibrary = await hre.ethers.deployContract("LibraryB");
await secondLibrary.waitForDeployment();
const secondLibraryAddress = await l2.getAddress();

const mainContract = await hre.ethers.deployContract("MainContract",{
  libraries:{
    LibraryA:firstLibraryAddress,
    LibraryB:secondLibraryAddress
  }
});

await mainContract.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const mainContract = await hre.zkEthers.deployContract("MainContract")
await mainContract.waitForDeployment();
```

::

### Common issues

- **Use of unsupported opcodes like SELFDESTRUCT or EXTCODECOPY.** The compiler will throw an error if any unsupported opcodes is used in one of the contracts.
See [differences with EVM opcodes here](/build/developer-reference/ethereum-differences/evm-instructions#coinbase).

## Testing

ZKSync provides different EraVM node implementations to test smart contracts locally:

- In-Memory Node: fast L2 node with non-persistent state.
- Dockerized local setup: L1 and L2 nodes with persistent state but slower performance.

You can read more about each node in the [Testing section of the docs](https://docs.zksync.io/build/test-and-debug).

### Running unit tests on In-Memory-Node

To run tests on the In-Memory Node, follow these steps:

1. The In-Memory Node is included in the `@matterlabs/hardhat-zksync` plugin, so make sure it’s installed and imported in your `hardhat.config.ts` file.
2. Add the `zksync:true` flag to the `hardhat` network in the `hardhat.config.ts` file.
3. Run the test task with `npx hardhat test`.

You can find more info about testing with the In-Memory-Node in [this section of the docs](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-node#running-hardhats-test-task-with-hardhat-zksync-node).

### Running tests on Dockerized local setup

To run tests on the Dockerized local setup, follow these steps:

1. Run `npx zksync-cli dev config` and select the “Dockerized node” option.
2. Run `npx zksync-cli dev start` to start the L1 and L2 nodes.
3. Add the Dockerized nodes to the list of networks in the `hardhat.config.ts` file:

```bash
networks: {
    dockerizedNode: {
      url: "http://localhost:3050",
      ethNetwork: "http://localhost:8545",
      zksync: true,
    },
    // Other networks

}
```

1.

## Deployment

Smart contract deployment on ZKsync Era (and chains build with ZK Stack) differs from Ethereum
as it’s handled by the `ContractDeployer` system contract
(see [this section of the docs to learn more](https://docs.zksync.io/build/developer-reference/ethereum-differences/contract-deployment)).

### Deployment with `hardhat-ethers`

Deployment of a simple contracts is quite straight forward.

::code-group

```typescript [hardhat-ethers]
const greeter = await hre.ethers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const greeter = await hre.zksyncEthers.deployContract('Greeter', ['Hi there!']);
await greeter.waitForDeployment();
```

::

In-case a custom deployment is needed, use `ContractFactory`.

::code-group

```typescript [hardhat-zksync-ethers]
const GreeterFactory = await hre.ethers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

```typescript [hardhat-zksync-ethers]
const GreeterFactory = await hre.zksyncEthers.getContractFactory('Greeter');
const greeterContract = GreeterFactory.deploy(); // if any, pass constructor arguments in deploy arguments
await greeter.waitForDeployment();
```

::

### Deployment with `hardhat-deploy`

The latest versions of the `hardhat-deploy` plugin include support for deployment on ZKsync
out of the box so there's no need to do any changes in the deployment scripts.

### Deployment with `hardhat-viem`

TODO

### Migrating from @openzeppelin/contracts-upgradable to hardhat-zksync-upgradeable

Deployment and upgrade functionalities of proxies has full interface compatability with `@openzeppelin/contracts-upgradeable`.

#### Deployment (proxy)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployProxy(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.zkEthers.getContractFactory("Box");
const box = await hre.zkUpgrades.deployProxy(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Proxy)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.zkEthers.getContractFactory("BoxV2");
const boxV2 = await hre.zkUpgrades.upgradeProxy(upgradableProxyAddress,boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

#### Deployment (beacon)

::code-group

```typescript [@openzeppelin/contracts-upgradable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.ethers.getContractFactory("Box");
const box = await hre.upgrades.deployBeacon(boxFactory, constructorArguments, {
   initializer: initializerFunctionName,
});
await box.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const boxFactory = await hre.zkEthers.getContractFactory("Box");
const box = await hre.zkUpgrades.deployBeacon(boxFactory, constructorArguments, {
  initializer: initializerFunctionName
});
await box.waitForDeployment();
```

::

#### Upgrade (Beacon)

::code-group

```typescript [@openzeppelin/hardhat-upgrades]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.ethers.getContractFactory("BoxV2");
const boxV2 = await hre.upgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

```typescript [hardhat-zksync-upgradeable]
const constructorArguments = [...];
const initializerFunctionName = 'initialize'
const upgradableProxyAddress = "UPGRADEABLE_PROXY_ADDRESS";
const boxV2ContractFactory = await hre.zkEthers.getContractFactory("BoxV2");
const boxV2 = await hre.zkUpgrades.upgradeProxy(upgradableProxyAddress, boxV2ContractFactory);
await boxV2.waitForDeployment();
```

::

### Custom deployment scripts with `hardhat-zksync`

You can write customized deployment scripts for ZKsync leveraging the `hre.deployer` object which is injected automatically by `@matterlabs/hardhat-zksync`.
The `Deployer` class provides helper methods to deploy smart contracts to ZKsync. Find [more info here](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-deploy#methods).

### Common issues

- **Contract size too large:** if the size of the generated bytecode is too large and can not be deployed, try compiling
the contract with the `mode: 3` flag in the `hardhat.config.ts` file to
optimize the bytecode size on compilation. [More info here](https://docs.zksync.io/build/tooling/hardhat/hardhat-zksync-solc#configuration).

## Smart Contract Verification

For ZKsync, the verification of a smart contracts does not differ from the commonly used verification process.

By installing `@matterlabs/hardhat-zksync`, a verification plugin is automatically added and ready to be used.

The only thing that is required to be modified is `hardhat.config.ts` file to include `verifyURL` in the network section.

::code-group

```typescript [url-zksync-sepolia-testnet]
  zkSyncSepoliaTestnet: {
    url: "https://sepolia.era.zksync.dev",
    ethNetwork: "sepolia",
    zksync: true,
    verifyURL: 'https://explorer.sepolia.era.zksync.dev/contract_verification'
  }
```

```typescript [url-zksync-mainnet]
  zkSyncMainnet: {
    url: "https://mainnet.era.zksync.io",
    ethNetwork: "mainnet",
    zksync: true,
    verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
  },
```

::

You can run the verification task programmatically inside a script as follows:

```js
const verificationId = await hre.run("verify:verify", {
  address: contractAddress,
  contract: contractFullyQualifedName,
  constructorArguments: [...]
});
```

Or execute the verification task from your terminal running:

```sh
npm hardhat verify --network testnet 0x7cf08341524AAF292255F3ecD435f8EE1a910AbF "Hi there!"
```

Find more info in [this section of the documentation](/build/tooling/hardhat/hardhat-zksync-verify).

## Scripting

TODO: Info about scripts to interact with deployed contracts.
